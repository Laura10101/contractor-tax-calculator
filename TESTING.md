# Testing

## Browser Compatability

## Code Validation

### HTML Validation

### CSS Validation

### JavaScript Validation

## Responsiveness

## User Story Tests

## API Tests

The main functionality for the tax calculator has been implemented across five different APIs. Collectively, these APIs comprise X complex model methods and more than 35 services. Each service is also exposed through a single API endpoint. While the API endpoints and services mostly provide basic CRUD functionality for different models, the rule calculations endpoint and service comprises more complex algorithms.

Given the scope of this project, comprehensively verifying the correctness of these services and methods through manual testing would not be feasible within a realistic timescale. I therefore opted to implement good automated test coverage across the APIs. 

To achieve this, testing was implemented at three levels:

1. **Model Tests** focus on testing the correctness of complex model methods. These tests assume that the model data has been validated by services and views and so aim to test whether the methods produce the correct output given valid input data.
2. **Services Tests** focus on testing the correctness of the services exposed by any API. These tests ensure that services are properly validating the input data they receive, that the database is correctly updated or read depending, and that any necessary model or third-party functionality is correctly called.
3. **Views Tests** focus on testing the correctness of the APIView methods to ensure that the incoming request is appropriately validated, that the appropriate service is invoked and completes as expected, that any response data is appropriately serialised and that the expected response and status code is therefore returned by the API.

### Forms API Tests ###

**Services Tests**
The following table lists the services tests for the Forms API. These tests can be found in forms_api/test_services.py while the asscoiated services can be found in forms_api/services.py.

| Test Name | Tested Service | Test Scenario | Expected Result |
| --------- | -------------- | ------------- | --------------- |
| 

**Views Tests**

### Jurisdiction API Tests ###

### Payments API Tests ###

### Rules API Tests ###

### Subscription API Tests ###

## Bugs

### Resolved Bugs
- When testing the POST method on the Jurisdiction API, the POST request repeatedly terminated as it was failing CSRF (Cross Site Request Forgery) validation. Since the API should be designed for open access by any authorised consumer, API views were made exempt by adding the csrf_exempt() decorator. Subsequently, the API was refactored to use Django REST, removing the need for this.
- When testing the POST method on the Jurisdiction API, the POST request failed to correctly serialise the response generated by the controller method. The safe=False attribute was added to the JsonResponse() call.
- When testing the GET method on the Jurisdiction API, the request failed to correctly serialise the retrieved models into a Json object. This was because the Django serializer was being applied to the values() dictionary from the return queryset, rather than to the queryset directly.
- When testing the DELETE method on the Jurisdiction API, the service method failed to correctly filter the queryset. This because the list of IDs was being passed into the filter method without specifying the parameter name. This was fixed by setting the pk__in parameter using the list of IDs.
- When testing the Forms API, the Django server failed to run as the class NumericAnswerValidation class was not defined, although the code was in models.py. This is because the NumericQuestion class was using the NumericAnswerValidation class before it had been defined. The solution was to define the NumericQuestion class after the NumericAnswerValidation class.
- When testing the Forms API, commas had been missed in the list of routes in urls.py.
- When testing the Forms API, the Django server failed to run as the “model” module could not be found. This was because the module is called “models” (plural).
- When testing the Forms API, the class “Jurisdiction” was not found in serializers.py. This is because the code had been copied from the Jurisdiction API, and the relevant line not changed. This was changed to the correct Model class (Form).
- When testing the Forms API, the Django server failed to run due to missing indentation in views.py. This was because a number of methods had not been implemented yet so “pass” was added into these methods.
- When testing the POST Jurisdictions endpoint after refactoring it to use Django REST, an error occurred. The error occurred because is_valid was not being called on the serializer before saving. Furthermore, when generating the response, “item.data” was being used for the response rather than “serializer.data” (item did not exist).
- When testing the GET Forms endpoint, an error occurred. This was because in the services layer (services.py), when querying forms based on jurisdiction ID, the Django filter had a typo and was being spelt jursidction_id rather than jurisdiction_id.
- When testing the DELETE Form endpoint, I received the error “Method \"GET\" not allowed”. Having double-checked that I was indeed sending a DELETE rather than a GET request, I noticed that the response to my DELETE request had the status code of 301. After Googling, I found the following link: Http Delete request to django returns a 301(Moved permenantly)_django_Mangs-DevPress官方社区 (csdn.net). It turned out that the issue was due to missing the closing slash on my request URL.
- When attempting to register the Order and OrderAdmin classes with the admin site, I received an error stating that the “sites” attribute did not exist. The correct attribute name should be “site”.
When attempting to create an order through the admin UI, I received an error informing me that there was no attribute on orders called “tonw_or_city”. The correct attribute name was “town_or_city”



### Unresolved Bugs
